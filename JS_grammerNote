Js Grammer Note

자바스크립트 기본
    1.자바스크립트는 <script>태그를 이용해 HTML문서 대부분의 위치에 삽입할 수 있다.
      <script src="/path/tp/script.js></script>를 통해 외부 스크립트를 불러올 수 있다. 

    2.코드구조
        자바 스크립트는 줄 바꿈이 있다면 세미콜론을 생략할 수 있다.
        하지만 세미콜론을 붙이는걸 권장한다. 

    3.엄격모드
        use strict 를 최상단에 작성해야 활성화 됩니다. 코드를 클래스와 모듈을 사용해 구성한다면 use strict를 사용할 필요는 없다.

    4.변수와 상수
        let을 이용해 선언한다. =(할당연산자)를 사용한다.
        변수 선언 방법.
          let a;
          a='hello';

          let a='hello';

          let a='hello', b=3;
          등이 있다.

        변수 명명 규칙.
          변수명에는 숫자와 문자, 기호 $ 와 _만 들어갈 수 있다.
          첫 글자는 숫자가 될 수 없다.

          let userName 
          여러 단어를 조합하여 변수명을 만들 때 카멜 표기법(첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성)을 보통 사용한다.

        변하지 않는 수는 const를 사용해 상수로 만든다.
        변수의 값이 절대 바뀌지 않을 것이라고 확신하면 const를 사용해 상수로 만들어준다. ex) 생일, 색상코드표의 값...

        대문자 상수
          기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습이다.
          이런 상수는 대문자와 밑줄로 구성된 이름으로 명명한다.
          ex) const COLOR_RED = "#F00";
              let color = COLOR_RED;   
    5.자료형
        숫자형
          let n=123; x=12.535;
          일반적인 숫자들 외에 Infinity , -Infinity, NaN 같은 특수 숫자 값도 포함.
          어떤 숫자던 0으로 나누면 무한대를 얻을 수 있다.
          계산 중에 에러가 발생했다면 NaN을 나타낸다.

        BigInt
          내부 표현 방식 때문에 자바스크립트에선 2^53-1보다 큰 값 혹은 -2^53+1 보다 작은 정수는 숫자형을 이용해 나타낼 수 없습니다.
          BinInt는 길이에 상관없이 정수를 나타낼 수 있습니다.
            let bigInt = 123151231123412124121231251231251241231231212n;

        문자형
          "",''사이에 들어간 값을 문자열로 간주합니다. 
          ``(역따옴표:backtick)로 변수나 표현식을 감싼 후 ${...}안에 넣으면 원하는 변수나 표현식을 문자열 중간에 넣울 수 있다.
           let name='John';
           alert(`hello, ${name}`);

        BooLean형
          true false 자료형입니다.

        null값
          자바스크립트에선 nothin, empty, unknown값을 나타내는 데 사용합니다.

        undefined
          변수를 선언했으나, 값이 할당되지 않았다면 자동으로 할당됩니다.

          let name;
          alert(name); //undefined출력
          
          개발자가 명시적으로 할당하는 것도 가능하긴 하나, 추천하지 않습니다.
          let name=undefined;

        객체와 심볼
          객체는 데이터 컬렉션과 복잡한 개체(entity)를 표현할 수 있습니다. 심볼(symbol)형은 객체의 교유한 식별자(unique identifier)를 만들 때 사용됩니다.

        typeof
          인수의 자료형을 반환합니다.
          typeof x //연산자 형
          typeof(x) //함수 형
          결과는 동일합니다.

      alert, prompt, confirm을 이용한 상호작용
        alert함수는 사용자가 확인 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 됩니다.

        prompt함수는 입력필드와 확인 취소 버튼이 있는 모달 창(메시지가 떠있는 작은창)을 띄워줍니다.
        prompt(title, [default]); //title:사용자에게 보여줄 문자열 //default 입력 필드의 초깃값

        confirm함수는 매개변수로 받은 question과 확인 취소버튼이 있는 모달창을 보여줍니다. 확인 버튼을 누르면 true, 아닐 시 false를 반환합니다.
        let isBool=confirm("사실인가요?")

      6.형 변환
        함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동변환됩니다. 이런 과정을 형 변환(type conversion)이라고 합니다.
        alert가 받은 값의 자료형과 관계없이 문자열로 자동 변환하여 보여주는 것이나, 수학 관련 연산자가 전달 받은 값을 숫자로 변환하는 경우가 예시입니다.

        문자형으로 변환
          alert에서 자동변환, String(value)함수를 호출해 변환.
        
        숫자형으로 변환
          수학과 관련된 함수와 표현식에서 자동으로 일어납니다.
          alert("6"/"2") // 3, 문자열에서 숫자형으로 변환 뒤 연산 수행.

          Number(value)함수를 사용하면 주어진 값을 숫자형으로 명시해서 변환할 수 있습니다.
          value에 숫자가 아닌 자료형이 있다면("hello 234")그 결과는 NaN이 됩니다.

          null과 undefined은 결과가 다릅니다. null은 0을 반환하고 undefined은NaN이 됩니다.

        불린형으로 변환
          0, 빈 문자열, null, undefined, NaN과 같이 직관적으로 비어있다고 느껴지는 값들은 false가 됩니다.
          하지만 문자열"0"은 true입니다. " "같이 공백이 있는 문자열도 비어있지 않기 떄문에 true입니다.

      7.기본 연산자와 수학
        단항: 피연산자를 하나만 받는 연산자를 단항 연산자로 부릅니다. -(마이너스)연산자가 대표적입니다
              ex) x = -x;
        
        이항연산자: 피연산자를 두개 받는 연산자. -연산자는 이항연산자로도 사용가능합니다.

        자바스크립트에서는 +,-,*,/,%,**연산자를 제공합니다.

        이항 연산자 + 와 문자열 연결
          +로 문자열이 전돨되면 문자열을 병합합니다.
          let s = "my" + "string";
          alert(s)// mystring;

          피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환됩니다.
          alert('1'+2);
          alert(2+'1');
          
          두개의 숫자 뒤에 문자열이 오는경우 숫자가 먼저 더해지고 병합이 이루어집니다.
          alert(2+2+'1')//41

          -이나 / 연산자의 경우 문자열이 숫자형으로 변환되고 연산이 진행됩니다.

          +는 단항 연산자로도 사용할 수 있습니다. 
          숫자에 붙이면 아무런 영향도 없으나 피연산자가 숫자형이 아닌 경우 숫자형으로 변환시켜줍니다.

          따라서 문자열끼리 덧셈을 할떄 이용할 수 있습니다.
          let apple = "2";
          let bee = "3";
          alert(+apple + +bee); // 5;

          =는 할당 연산자입니다. 연산자이기 때문에 이러한 연산이 가능합니다.
            let a = 1;
            let b = 2;
            let c = 3-(a=b+1); // 0
            실제로 쓰는건 추천하지 않습니다.

          복합할당연산자
            n=n+5같은 자기 자신에 대한 연산을
            n += 5로 줄일 수 있습니다.
            복합 할당 연산자의 우선순위는 할당연산자와 동일하므로, 대부분의 다른 연산자들이 실행된 후에 복합 할당 연산자가 실행됩니다.
            let n =2;
            n *= 3+5;
            alert(n); // 16

          증가 감소 연산자
            ++ //+1 입니다.
            -- // -1 입니다.
            증가 감소연산자는 변수의 앞이나 뒤에 쓸 수 있습니다. 뒤에 올때는 후위형, 앞에 올 떄는 전위형이라고 부릅니다.
            전위형은 값을 반환하기 전 값을 증가시키고, 후위형은 값을 반환한 후 값을 증가시킵니다.
            let counter = 1;
            let a = ++counter;
            a // 2

            let counter = 1;
            let a = counter++;
            a // 1

            증가 감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에 평가가 먼저 이뤄집니다. 
            let counter = 1;
            alert(2* ++counter); //4

            코드의 가독성을 위해 코드 한 줄엔, 특정 동작 하나에 관련된 내용을 작성하는 것이 좋아 보통은 따로 계산합니다.

          비트 연산자
            인수를 32비트 정수로 변환하여 이진 연산을 수행합니다.
            & : 비트 AND
            | : 비트 OR
            ^ : 비트 XOR
            ~ : 비트 NOT
            << : 왼쪽 시프트
            >>: 오른쪽 시프트
            >>>:부호 없는 오른쪽 시프트

          쉼표 연산자
            코드를 짧게 쓰려는 의도로 가끔 사용됩니다. 
            여러 표현식을 코드 한 줄에서 평가할 수 있게 해주지만, 마지막 표현식의 평가 결과만 반환되는 점에는 유의해야 합니다.
            let a = (1+2, 3+4);
            alert(a);
            쉼표 연산자는 할당 연산자= 보다 우선순위가 낮습니다.

        8.비교 연산자
          ==, <, >, >=, <=, != 가 각각 존재합니다. 
          불린형 반환
            비교 연산자의 결과가 true, false입니다.

          문자열 비교
            JS는 사전 순으로 문자열을 비교합니다. 사전편집(Lexicographcal)이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.(정확히는 유니코드 순입니다. 따라서 소문자가 더 큽니다.)
            alert('z' > 'a'); // true
            alert('Glow'>'Glee'); // true
            alert('Bee' > 'be');//true
            앞부터 순서대로 비교해서 같은 문자열은 같다고 판단하고 비교합니다.
            비교가 종료되었을 때 두 문자열의 길이가 다르다면 긴 쪽이 크다고 결론냅니다.

          다른 형을 가진 값 간의 비교
            비교하려는 값의 자료형이 다르면 자바스크립트는 이 값을 숫자형으로 바꿉니다.

            alert('2' >1); // true, 문자열 2가 숫자 2로 변환됩니다.
            불린값의 경우 true는 1, false는 0으로 변환됩니다.

          일치 연산자
            동등 연산자 == 은 0과 false를 같다고 봅니다.
            0 == false // true
            이 문제를 어떻게 해결 할 수 있을까요?
            일치 연산자(===)를 사용합니다. 
            일치 연산자는 엄격한 동등 연산자 입니다. 따라서 좌우 항의 형이 다를 경우 false를 반환합니다.

          null과 undefined비교
            동등 연산자는 같다고 보고(주의: 0으로 변환시키는게 아닙니다. 동등 연산자는 null과 undefined을 형변환 시키지 않습니다. 둘을 같이 비교할 때만 true를 반환합니다), 일치연산자는 다르다고 봅니다.
        
        9.if와 ?를 사용한 조건 처리
          if(...)문은 괄호안의 결과가 true면 코드블럭을 실행합니다.
          괄호안의 표현식을 평가하고 그 결과를 불린값으로 변환합니다.
          뒤에 else절을 붙일 수 있습니다.
          else if로 복수의 조건을 붙일 수 있습니다.

          조건부 연산자 '?'
            조건에 따라 다른 값을 변수에 할당해줘야 할 때가 있습니다.
            if(age > 18){
              accessAllowed = true;
            }else{
              accessAllowed = false;
            }

            물음표 연산자인 조건부 연산자를 사용하면 위 예시를 더 짧고 간결하게 변형할 수 있습니다.
            피연산자가 3개이기 때문에 삼항 연산자라고 부르기도 합니다.

            let result = condition ? value1 : value2;
            평가 대상인 condition이 참값이면 value1, 거짓이면 value2가 반환됩니다.
            ?연산자는 우선순위가 낮습니다.

            물음표 연산자를 여러개 연결하면 복수의 조건을 처리할 수 있습니다.
            let message = (age<3)? 'Hi':
            (age < 18) ? 'hello' :
            (age < 100) ? 'welcome!' :
            'You over the age!' ;

            물음표 연산자를 if대신 쓰기보다는 반환값을 달리하려는 목적으로 만들었기 떄문에 필요할 때만 사용하고, 대부분은 if절을 사용하도록 합시다.

        10.논리 연산자
          || : OR
          && : AND
          ! : NOT

              자바스크립트에서 OR연산자의 추가 기능을 알아보겠습니다.
              result = value1 || value2 || value3
              위 연산은 다음 순서를 따릅니다.
              가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가합니다.
              각 피연산자를 불린형으로 변환합니다. 변환 후 그 값이 true이면 연산을 멈추고 해당 피 연산자의 변환 전 원래 값을 반환합니다.
              피연산자 모두를 평가한 경우 (모든 피연산자가 false로 평가되는 경우)엔 마지막 피연산자를 반환합니다.

              핵심은 반환 값이 형 변환을 하지 않은 원래 값이라는 것 입니다.

              정리를 해보자면 Or연산자를 여러개 체이닝하면 첫 번재 truthy를 반환합니다. 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환합니다.
              alert( null || 1 || 0); // 1
              alert( undefined || null || 0); // 0 모두 falsy이기 때문에 마지막 값을 반환했다.

              이런 기능은 다음과 같이 활용할 수 있습니다.

              1. 변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy얻기
              firstName, lastName, nickName이란 변수가 있는데 이 값들이 모두 옵션값이라고 한다면, || 연산자를 활용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있습니다.
              변수 모두에 값이 없는 경우엔 익명을 보여줍니다.

              let firstName = "";
              let lastName = "";
              let nickName = "VAO";
              alert(firstName||lastName||nickName||"익명");

              2. 단락 평가
              연산자 왼쪽 조건이 falsy일 때 명령어를 시행하고자 할떄 쓰입니다.
          
          &&(AND)
            두 피연산자가 모두 참일 때 true를 반환합니다.
            &&연산자도 체이닝이 가능합니다. OR와는 다르게 순차적으로 평가 중 false값이 나오면 해당 연산자의 변환 전 값을 반환합니다.
            OR와 반대라고 생각하면 됩니다.

          !(NOT)
            인수를 하나만 받고 그 반대인 불린 값으로 변환합니다.
            true면 false로, false면 true로 반환합니다.

            특수한 용법으로 !!처럼 두번 사용하면 값을 불린형으로 변환할 수 있습니다
            !!"non" // 문자열이 비어있지 않으므로 true
            
          null 병합 연산자 '??'
            a??b의 평가 결과는 다음과 같습니다. 
            a가 null도 아니고 undefined도 아니면 a,
            그 외의 경우는 b

            동일한 동작을 하는 코드를 작성하면 다음과 같습니다.
            x=( a !== null && a !== undefined) ? a : b;

            언뜻 OR연산자와 유사하지만 null, undefined, 0을 구분 지어 다룰 때 중요한 역할을 합니다.
            let height = 0;
            alert(height || 100); // 100 0이 falsy처리
            alert(height ?? 100); // 0 null과 undefined이 아니기 때문에 height반환

            연산자의 우선순위는 ? = 보다는 높습니다. 그외엔 대부분 낮기 때문에 소괄호와 함께 연산하는 편이 좋습니다.

            안정성 관련 이슈 때문에 ?? 는 &&과 ||와 함께 사용하지 못합니다.
            괄호를 사용하면 사용할 수 있습니다.

        11. While 과 for 반복문
          while문법은 다음과 같습니다.
            while(condition){

            }

            condition이 truthy면 작동합니다.
            본문이 한 줄이면 {..}대괄호를 생략할 수 있다.
            let i = 3;
            while(i) alert(i--)

          do...while반복문을 사용하면 condition을 본문 아래로 옮길 수 있습니다.
          let i = 0;
          do{
            alert(i);
            i++;
          }while( i < 3 );

          do while 문은 조건이 truthy가 아니라도 한번은 본문을 수행합니다. 대다수의 상황에서 while문을 사용합니다.
          
          for반복문
          for(begin; condition; step){
            //body
          }
            begin: 반복문에 진입시 한번 실행
            condition: 반복마다 해당 조건이 확인된다. false면 동작정지
            body: condition 이 truthy일 동안 계속 실행
            step: 각 반복의 body실행 후 실행

          구성요소 생략가능
          let i=0; //선언과 할당 완료.
          for(; i<3;){
            alert(i++);
          }

          for(;;) //무한반복

          break로 반복문 탈출 가능.
          continue로 다음 반복으로 넘어가기 가능. continue는 중첩을 줄이는 데 도움을 준다. (중첩은 {}를 계속 열어 깊이가 깊어지는것으로 추정)

          ?(삼항연산자) 오른쪽에는 break와 continue가 올 수 없다.

          break/continue와 레이블
            여러개의 중첩을 한 번에 빠져나올시 사용.

            양식
            labelName: for(...){
              ...
            }

            사용
            outer: for(let i=0; i<3; i++){
              for(let j=0; j<3; j++){
                break outer; // outer이라는 레이블이 붙은 반복문을 찾고 빠져나온다.
              }
            }

            엔터로 별도의 줄에도 사용할 수 있다.
            outer:
            for(...){...}

            break와 continue는 반복문 안에서만 사용할 수 있고, 레이블은 반드시 break와 continue지시자 위에 있어야 한다.

        12.switch문
          복수의 if문은 switch문으로 변환할 수 있다.
          문법
            switch(x){
              case 'value1':
              ...
              break;

              case 'value2':
              ...
              break;
              default:
              alert("값을 모름");
            }

            케이스의 value값과 일치하는지 절차대로 탐색하고 맞다면 그 case를 실행, 어떤 case도 없다면 default의 구문을 실행.

            case안에 break가 없다면 조건에 부합하는지 여부를 따지지 않고 이어지는 case문을 실행
            
              case 3:
                hi
              case 4:
                hello
              case 5:
                good
              default: bye 
              //hello->good->bye

            switch/case의 인수에는 어떤 표현식도 올 수 있다.
            let a='1';
            let b=0;
            switch (+a){
              case b+1:
                alert('hi');
                break;
            }

            case문 묶기
              
              case 3:
              case 5:
                alert("byr");
                break;

              3과 5일 경우 실행되는 케이스입니다.

            비교하려는 값과 case문의 값의 형이 같아야 실행됩니다. 자료형을 맞춰야합니다.

          13.함수
            함수 선언
            function show(){
              ...
            }
            show();

            함수에선 외부변수에 접근, 수정할 수 있습니다.
            지역변수가 외부변수와 이름이 동일하다면 지역변수만 사용합니다.

            매개변수를 사용하면 데이터가 매개변수에 복사됩니다.

            값을 전달하지 않으면 undefined가 됩니다

            기본값 설정을 해두면 undefined가 발생하지 않습니다.

            function show(from, text="default value"){
              ...
            }

            또는 함수 안에 if, ||, ?? 같은것을 사용하는 방법도 있습니다.

            함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 
            return구문을 사용합니다.

            return만 사용하는 경우 함수가 즉시 종료됩니다.

          14. 함수 표현식
            자바스크립트에선 함수를 특별한 종류의 값으로 취급합니다. 구조로 취급되지 않습니다.

            함수를 선언하면 다음과 같습니다.
            function sayHi(){
              alert("hello");
            }

            함수 표현식을 사용하면 다음과 같습니다.
            let sayHi = function(){
              alert("hello");
            };

            변수에 함수가 할당되었습니다.

            함수는 값으로 취급받기 때문에 

            let func = sayHi;
            와 같이 ()를 붙이지 않으면 함수의 코드가 복사됩니다.
            따라서 func();은 sayHi();와 같은 기능을 합니다.

            dd
